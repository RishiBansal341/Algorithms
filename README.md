## Contents(İçindekiler)

1. [Algorithms(Algoritmalar)](#algorithms)
    1. [Searcing Algorithms(Arama Algoritmaları)](#searcing-algorithms)
        1. [Linear(Sequential) Search(Doğrusal Arama)](#linear-search)
        1. [Jump Search(Atlamalı Arama)](#jump-search)
        1. [Binary Search(İkili Arama)](#binary-search)
        1. [Interpolation Search(Ara Değer Bularak Arama)](#interpolation-search)
    1. [Sorting Algorithms(Sıralama Algoritmaları)](#sorting-algorithms)
        1. [Bubble Sort(Kabarcık Sıralama)](#bubble-sort)
        1. [Merge Sort(Birleştirme Sıralama)](#merge-sort)
        1. [Insertion Sort(Eklemeli Sıralama)](#insertion-sort)
        1. [Selection Sort(Seçerek Sıralama)](#selection-sort)
        1. [Quick Sort(Hızlı Sıralama)](#quick-sort)
        
## Algorithms

<p>&nbsp&nbsp&nbsp&nbsp&nbspAlgoritma, istenen çıktıyı elde etmek için belirli bir sırada gerçekleştirilecek bir dizi talimatı adım adım tanımlayan bir prosedürdür. Algoritmalar genellikle altta yatan dillerden bağımsız olarak oluşturulur, yani birden fazla programlama dilinde bir algoritma uygulanabilir.</p>

### Searcing Algorithms

<ul>
    <li>
        <b id="linear-search">Linear Search</b> - Doğrusal arama çok basit bir arama algoritmasıdır. Tüm öğeler üzerinde birer birer sıralı bir arama yapılır. Her değer kontrol edilir ve eğer bir eşleşme bulunursa o zaman o değerin bulunduğu index geri döndürülür, aksi takdirde üzerinde arama yapılan veri dizisinin sonuna kadar arama devam eder. Sıralı ve sıralı olmayan veri dizisi üzerinde olmak üzere 2 farklı şekilde oluşturulabilir:
        <ul>
            &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/linear_search.gif" alt="Linear Search"/>
            <li>
                <b>For Unordered List</b> : Sıralı olmayan veri dizisinde arama, aranan eleman bulunmadığı takdirde veri setinin sonuna kadar devam eder.
            </li>
            <li>
                <b>For Ordered List</b> : Sıralı veri dizisinde ise aranan eleman dizideki her elemanla kıyaslanırken eğer kıyaslandığı elemandan küçük(veri dizisi küçükten büyüğe doğru sıralanmış ise) olduğu bir durum olursa, dizi sıralı olduğu için aranan elemanın ilgili index'ten sonra bulunabilme ihtimali olmayacağı için arama otomatik olarak sonlandırılır. Böylece zaman açısından daha verimli bir sonuç elde edilir.<br><br>
            </li>
        </ul>
    </li>
    <li>
        <b id="jump-search">Jump Search</b> - Atlamalı arama doğrusal aramaya göre daha hızlı, ikili aramaya göre daha yavaş kalan ve sıralı veri setleri üzerinde çalışan bir arama algoritmasıdır. Temel fikir, sabit adımlarla ileriye atlayarak, dizinin tüm elemanlarını aramak yerine bazı elemanları atlayarak doğrusal aramaya göre daha az elemanı kontrol etmektir.<br>
        &nbsp&nbsp&nbsp&nbsp&nbsp<b>&nbsp &#x27A5;&nbspStep Size:&nbsp</b>Jump search yaparken aradığımız değerin en kötü ihtimalle dizinin sonlarında olduğunu düşünelim. Bu durumda en kötü ihtimalle dizinin n elemanlı ise ve atlama adım büyüklüğümüz <b>m</b> ise <b>(n / m)</b> kadar atlama yapmış oluruz. <b>(n / m)</b> atlama yaptıktan sonra da aradığımız değerin bu son adımımızın içinde olduğunu ve bu adımın içindeki son eleman olduğunu düşünürsek <b>(m - 1)</b> eleman daha kontrol etmiş oluruz. Yani en kötü durumda toplam karşılaştırma sayısı:<br>
        <b><code>(n / m) + (m - 1)</code></b><br>
        olacaktır. Algoritmanın performansı ve hızı açısından bu eşitliğin minimum değer üretmesini isteriz. Bu yüzden bu ifadenin üretebileceği minimum değeri bulmak için(yerel minimum noktası arıyoruz) denklemin <b>m</b> değerine göre türevini alıp sıfıra eşitleriz:<br>
        <b><code>n / -m<sup>2</sup> + 1 = 0</code></b><br>
        ifadesini elde etmiş olduk. Bu ifadeyi de çözümleyecek olursak:
        <b><code>n = m<sup>2</sup></code></b><br>
        <b><code>m = √n</code></b><br>
        Böylece atlamalı aramada tercih edilecek en iyi atlama adımı uzunluğunu dizinin boyunun karekökü olarak bulmuş olduk. Örneğin aşağıdaki dizi içerisinde 5 değerini atlamalı arama ile bulmaya çalışalım:<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/jump-search-1.jpg" alt="Jump Search"/><br><br>
        Öncelikle step size yani atlama adımı uzunluğumuzu bulalım. Dizi 9 elemanlı olduğu için:<br>
        <b><code>step_size = √9 = 3</code></b><br>
        olarak bulunmuş olur. Daha sonra ilk elemandan itibaren 3 adım atlayarak bulunduğumuz değeri aradığımız değer ile karşılaştırırız. İlk atlamadaki 4 değeri ile 5 değeri eşleşmediği ve 4 değeri 5 değerinden küçük olduğu için bir adım daha atlarız. İkinci atlamamızda bulunduğumuz indisin 7 olan değeri aradığımız 5 değerinden büyük olduğu için artık ileriye doğru atlama yapmayız ve bu değerimizi bir önceki adımımızda durduğumuz indis ile şu an durduğumuz indis arasında doğrusal arama yaparak ararız. Böylece aradığımız 5 değerini dizinin 4 numaralı indisinde bulmuş oluruz.<br><br>
    </li>
    <li>
        <b id="binary-search">Binary Search</b> - İkili arama böl ve yönet prensibi ile çalışan hızlı bir arama algoritmasıdır. Bu algoritma sıralı veri setleri üzerinde düzgün olarak çalışır. İkili arama, aranan değer ile veri dizisinin en ortasındaki değeri karşılaştırır. Bir eşleşme olursa, o zaman ilgili index geri döndürülür. Eşleşme olmamışsa ve ortadaki değer aranan değerden büyükse, değer ortadaki indexin solundaki alt dizide, aksi halde ortadaki indexin sağındaki alt dizide aranır. Bu işlem, alt dizinin boyutu sıfıra inene kadar devam eder. Görselleştirilmiş bir örnek ile ikili aramayı daha iyi anlayacağınızı umuyorum.<br><br>
    Aşağıdaki sıralı dizide 31 değerininin indexini bulmaya çalıştığımızı varsayalım:<br><br>  &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/binary_search_0.jpg" alt="Binary Search0"/><br><br>
        Öncelikle dizinin ortasındaki indexi belirleyeceğiz:<br>
        <br><b><code> mid = low + (high - low) / 2 </code> &nbsp&nbsp --> &nbsp&nbsp <code>mid = 0 + (9 - 0) / 2 = 4.5</code></b>&nbsp&nbsp(4 tamsayı değeri)<br><br>      &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/binary_search_1.jpg" alt="Binary Search1"/><br><br>
        Yani dizinin ortasındaki indis 4 olarak bulunur. Daha sonra dizinin 4. indisindeki değer ile aranan değer yani 31 değeri karşılaştırılır. Dizinin 4. indisindeki 27 değeri ile aranan 31 değerinin eşleşmediği tespit edilir. Aranan 31 değeri 27'den büyük olduğu ve dizimiz de sıralı bir dizi olduğu için, aranan değerimiz dizinin üst kısmında(4. indisin sağ tarafındaki alt dizide) bulunabilir. Bu yüzden 31 değerini bu alt dizide aramak üzere dizimizin en küçük indisini ortanca indisten 1 büyük olmak üzere güncelleyeceğiz:<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/binary_search_2.jpg" alt="Binary Search2"/><br><br>
        <code><b> low = mid + 1 </b></code><br><code><b> mid = low + (high - low) / 2 </b></code>
        Artık yeni ortanca indisimiz 7 olduğu için, 7. indisteki değer ile 31 değerini karşılaştırıyoruz.<br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/binary_search_3.jpg" alt="Binary Search3"/><br><br>
        Dizinin 7. indisindeki değer ile aradığımız 31 değeri eşleşmediği için ve aradığımız değer bu indisteki 35 değerinden küçük olduğu için aranan değerimizi alt dizinin alt dizisinde(7. indisin sol tarafındaki yeni alt dizide) aramalıyız.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/binary_search_4.jpg" alt="Binary Search4"/><br><br>
        <code><b> high = mid - 1 </b></code><br><code><b> mid = low + (high - low) / 2 </b></code>
        Yeni ortanca indisimiz 5 olarak hesaplanmış oldu.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/binary_search_5.jpg" alt="Binary Search5"/><br><br>
        Dizinin 5. indisindeki değer ile aradığımız değeri tekrar karşılaştığımızda bir eşleşme olduğunu tespit ettik.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/binary_search_6.jpg" alt="Binary Search6"/><br><br>
        Böylece aradığımız değerin hedef veri setinin 5. indisinde bulunduğu sonucunu elde etmiş olduk.<br><br>
    </li>
    <li>
        <b id="interpolation-search">Interpolation Search</b> - İnterpolasyon arama algoritması ikili arama algoritmasına çok benzer bir algoritmadır. Yine sıralı veri setleri üzerinde, böl ve yönet prensibiyle çalışır. İkili aramadan farkı ise ikili arama algoritması ile arama yaparken dizinin ortanca elemanına bakıyorduk ve karşılaştırma sonucuna göre diziyi ikiye bölüp dizinin sağ veya sol alt dizisinde değerimizi arıyorduk. İnterpolasyon aramada ise diziyi böleceğimiz pozisyon değerini, yani merkez alınacak indisi aşağıdaki formül ile hesaplıyoruz:<br><br>
        <code><b> position = low + [  (high - low) / (array[high] - array[low]) * (value - array[low]) ] </b></code><br>
        &nbsp&nbsp&nbsp&nbsp<b><em>position</em></b>&nbsp&#x27BA;&nbspKarşılaştırma yapacağımız ve karşılaştırma sonucuna göre diziyi bölmek için baz alacağımız pozisyon<br>
        &nbsp&nbsp&nbsp&nbsp<b><em>array</em></b>&nbsp&nbsp&nbsp&nbsp&nbsp&#x27BA;&nbspArama yaptığımız dizi<br>
        &nbsp&nbsp&nbsp&nbsp<b><em>low</em></b>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&#x27BA;&nbspDizinin en küçük indisi<br>
        &nbsp&nbsp&nbsp&nbsp<b><em>high</em></b>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&#x27BA;&nbspDizinin en büyük indisi<br>
        &nbsp&nbsp&nbsp&nbsp<b><em>value</em></b>&nbsp&nbsp&nbsp&nbsp&nbsp&#x27BA;&nbspDizide bulmak için arama yaptığımız değer<br><br>
        Algoritma ise aşağıdaki adımlardan oluşuyor:<br>
        <ul>
            <li>
                Pozisyon değerini hesapla ve aranan değer ile dizinin pozisyon numaralı indisindeki değeri karşılaştır.
            </li>
            <li>
                Eşleşme olursa geriye değerin bulunduğuna dair bir sonuç döndür.
            </li>
            <li>
                Aksi halde, aranan değer dizinin ilgili indisinden küçükse sol, büyükse sağ alt dizide pozisyon hesapla ve arama yap.
            </li>
            <li>
                Eşleşme bulunana kadar veya alt dizi boyutu 0 olana kadar işlemlere devam et.
            </li>
        </ul>
    </li>
</ul>

### Sorting Algorithms

<p>&nbsp&nbsp&nbsp&nbsp&nbspSıralama algoritmaları, verileri belirli bir düzende sıralama yollarını belirtir. En yaygın sıralamalar sayısal veriler veya sözlük sıralamalarıdır. Sıralamanın önemi, veriler sıralı bir şekilde saklanırsa, bu veriler üzerinde arama yapmanın çok yüksek bir performans düzeyine getirilebileceği gerçeğinde yatmaktadır. Sıralama, telefon rehberlerinde veya sözlüklerdeki kelimelerde olduğu gibi verileri daha okunabilir formatlarda göstermek için de kullanılabilir.</p>
<ul>
    <li>
        <b id="bubble-sort">Bubble Sort</b> - Kabarcık sıralama basit bir sıralama algoritmasıdır. Bu sıralama algoritması, her bir bitişik eleman çiftinin karşılaştırıldığı ve sıralı olmadıklarında elemanların yer değiştirildiği karşılaştırma tabanlı bir algoritmadır. Bu algoritma, büyük veri kümeleri için uygun değildir. Çünkü n elemanlı bir dizi için ortalama ve en kötü durum karmaşıklığı O(n<sup>2</sup>)'dir. Aşağıdaki örnek ile kabarcık algoritmasını görselleştirerek anlamaya çalışalım:<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/bubble_sort_0.jpg" alt="Bubble Sort0"/><br><br>
        Şekildeki gibi sıralanmamış ve kısa bir diziyi kabarcık sıralama algoritması ile sıralayacağız. Bunun için ilk iki elemandan başlayarak ikişerli ikişerli karşılaştırma yapacağız.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/bubble_sort_1.jpg" alt="Bubble Sort1"/><br><br>
        İlk karşılaştırmada 33 değeri zaten 14 değerinden büyük olduğu için ilk 2 değerin zaten sıralanmış olduğunu görüyoruz. Bu yüzden yer değiştirme yapmadan sonraki 2 değer olan 33 ile 27 değerini karşılaştırıyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/bubble_sort_2.jpg" alt="Bubble Sort2"/><br><br>
        27 değeri ile 33 değerini karşılaştırdığımızda 27 değeri 33 değerinden küçük olduğu için bu iki değerin yer değiştirmesi gerektiğini tespit ettik.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/bubble_sort_3.jpg" alt="Bubble Sort3"/><br><br>
        Yer değiştirme işleminden sonra dizimiz aşağıdaki gibi olmalı:<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/bubble_sort_4.jpg" alt="Bubble Sort4"/><br><br>
        Sıralama işlemine kaldığımız yerden devam ediyoruz ve 33 ile 35 değerlerini karşılaştırıyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/bubble_sort_5.jpg" alt="Bubble Sort5"/><br><br>
        Zaten sıralı oldukları için yer değiştirme yapmadan sıralama işlemine devam ediyoruz ve 35 ile 10 değerlerini karşılaştırıyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/bubble_sort_6.jpg" alt="Bubble Sort6"/><br><br>
        10 değeri 35 değerinden küçük olduğu için sıralı olmadıklarını ve bu 2 değerin yer değiştirmesi gerektiğini tespi ettik.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/bubble_sort_7.jpg" alt="Bubble Sort7"/><br><br>
        Bu 2 değerin yerlerini değiştiriyoruz ve dizinin sonuna geldiğimizi görüyoruz. Böylece dizideki en büyük eleman dizinin sonuncu indisine yerleşti ve dizimiz şimdilik aşağıdaki gibi oldu.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/bubble_sort_8.jpg" alt="Bubble Sort8"/><br><br>
        Tüm dizi sıralanana kadar algoritmayı uygulamaya devam ediyoruz ve bunun için tekrar ilk indisten başlayarak son indis hariç bir şekilde aynı işlemleri uyguluyoruz. Böylece bir sonraki iterasyonda dizimiz aşağıdaki gibi görünecektir.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/bubble_sort_9.jpg" alt="Bubble Sort9"/><br><br>
        Bir sonraki iterasyondan sonra ise dizimiz aşağıdaki gibi görünüyor ve her iterasyondan sonra en az 1 değerin yer değiştirdiğini görüyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/bubble_sort_10.jpg" alt="Bubble Sort10"/><br><br>
        İterasyonlara devam ederken herhangi bir yer değiştirme işlemine gerek kalmadığında kabarcık sıralama algoritması ile verilerimizi sıralamış oluruz ve nihai olarak dizimiz aşağıdaki gibi olur.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/bubble_sort_11.jpg" alt="Bubble Sort11"/><br><br>
    </li>
    <li>
        <b id="merge-sort">Merge Sort</b> - Birleştirme sıralama, böl ve yönet tekniğine dayanan bir sıralama algoritmasıdır. Merge sort, sıralanacak diziyi alt dizi eleman sayısı 1 olana kadar sürekli yarıya böler ve sonra en küçük alt diziden en büyük diziye doğru bu alt dizileri sıralı bir şekilde birleştirir. Aşağıdaki gibi sıralanmamış bir dizimiz olsun:<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/MergeSort/unsorted_array.jpg" alt="Merge Sort0"/><br><br>
        Atomik değerler elde edene kadar sıralamak istediğimiz diziyi yinelemeli olarak 2 eşit parçaya böleceğiz. 8 elemandan oluşan dizimizi ilk aşamada 4 elemanlı 2 eşit parçaya böldük.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/MergeSort/merge_sort_divide_1.jpg" alt="Merge Sort1"/><br><br>
        Sıralama işlemi dizi atomik değerlere parçalanana kadar başlamayacağı için yarılanmış parçalar henüz sıralı olmayacaktır. Atomik değerler elde edene kadar elde edilen alt dizileri de 2 eşit parçaya bölmeye devam ediyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/MergeSort/merge_sort_divide_2.jpg" alt="Merge Sort2"/><br><br>
        Elde edilen dizileri 2 eşit parçaya bölme işlemine devam ediyoruz ve sonunda tek elemanlı atomik dizilerimizi elde ediyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/MergeSort/merge_sort_divide_3.jpg" alt="Merge Sort3"/><br><br>
        Şimdi sıra atomik değerlerimizi sıralayarak birleştirme işlemine geldi. Karşılaştırma yapıp sıralayarak birleştireceğimiz diziler aynı renklerde gösterilmiştir. Öncelikle aynı renklerdeki listelerin değerlerini karşılaştırırız ve daha sonra bunları sıralı bir şekilde başka bir listede birleştiririz. 14 ve 33 değerlerinin sıralı pozisyonlarda olduğunu görüyoruz. 27 ile 10 değerlerini karşılaştırıyoruz ve 10 değeri 27 değerinden küçük olduğu için bu iki değeri ilk elemanı 10 olacak şekilde birleştiriyoruz. 19 ve 35 değerlerinin de sırasını değiştirirken 42 ve 44 değerlerinin sırasını değiştirmeden bu elemanları da birleştiriyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/MergeSort/merge_sort_combine_1.jpg" alt="Merge Sort4"/><br><br>
        Birleştirme aşamasının bir sonraki iterasyonunda, daha önce birleştirme yaparak elde ettiğimiz listeleri karşılaştırır ve elemanları sıralı olacak şekilde bu listeleri de birleştiririz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/MergeSort/merge_sort_combine_2.jpg" alt="Merge Sort5"/><br><br>
        Son iterasyon ile yapılacak birleştirme işleminden sonra da listemiz nihai olarak aşağıdaki şekilde görünecektir.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/MergeSort/merge_sort.jpg" alt="Merge Sort6"/><br><br>
    </li>
    <li>
        <b id="insertion-sort">Insertion Sort</b> - Ekleme sıralama algoritması yerinde karşılaştırma tabanlı bir sıralama algoritmasıdır. Bu algoritmada her zaman, sıralanan bir alt liste tutulur. Algoritmada dizinin ilk elemanı alt liste olarak belirlenir ve ilk aşamada alt listede zaten tek eleman olduğu için bu alt liste sıralıdır. Dizinin ikinci indisinden başlanarak ve her iterasyondan sonra indis numarası da son iterasyonda dizi boyutu olacak şekilde artırılarak, her iterasyonda dizinin daha küçük indislerine doğru karşılaştırma yapılır ve her eleman kendine uygun sırayı bulduğunda sırayla alt diziye eklenir. Aşağıdaki örnek ile algoritmamızı daha detaylı inceleyelim.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/InsertionSort/unsorted_array.jpg" alt="Insertion Sort0"/><br><br>
        İlk iki elemanı karşılaştırarak algoritmayı uygulamaya başlıyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/InsertionSort/insertion_sort_1.jpg" alt="Insertion Sort1"/><br><br>
        İlk iki değer olan 14 ve 33 değerlerinin sıralanmış olduğunu yani 14 değerinin konumunun doğru olduğunu tespit ediyoruz ve 14 değerine sıralanmış alt listede yerini veriyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/InsertionSort/insertion_sort_2.jpg" alt="Insertion Sort2"/><br><br>
        Algoritmayı uygulamaya devam ediyoruz ve 27 değeri ile 33 değerini karşılaştırıyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/InsertionSort/insertion_sort_3.jpg" alt="Insertion Sort3"/><br><br>
        Karşılaştırmada 33 değerinin konumunun doğru olmadığını tespit ediyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/InsertionSort/insertion_sort_4.jpg" alt="Insertion Sort4"/><br><br>
        Sıralı olmadıkları için 27 ile 33 değerlerinin yerini değiştiriyoruz ve sıralanmış alt listedeki tüm elemanları 27 ile karşılaştırmaya devam ederek konumlarını kontrol ediyoruz.Sıralanmış alt listenin tek elemanı olduğunu ve 14 değerine sahip bu elemanın zaten 27 değerinden küçük olduğunu görüyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/InsertionSort/insertion_sort_5.jpg" alt="Insertion Sort5"/><br><br>
        Sonuç olarak şu anda alt listemize 14 ve 27 değerleri yerleşmiş bulunmaktalar. Algoritmayı uygulamaya kaldığımız yerden devam ediyoruz ve 10 değeri ile 33 değerlerini karşılaştırıyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/InsertionSort/insertion_sort_6.jpg" alt="Insertion Sort6"/><br><br>
        Bu 2 değerin sıralı olmadıklarını görüyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/InsertionSort/insertion_sort_7.jpg" alt="Insertion Sort7"/><br><br>
        Sıralı olmadıkları için bu iki değerin yerlerini değiştiriyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/InsertionSort/insertion_sort_8.jpg" alt="Insertion Sort8"/><br><br>
        Bu yer değiştirme işleminden sonra 10 değerini alt listeyle en küçük indise inene veya bu değerin alt listedeki doğru konumunu bulana kadar karşılaştırmaya devam ediyoruz ve 10 ile 27 değerlerinin de sıralı olmadığını tespit ediyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/InsertionSort/insertion_sort_9.jpg" alt="Insertion Sort9"/><br><br>
        Sıralı olmadıkları için 10 ve 27 değerlerinin de yerlerini değiştiriyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/InsertionSort/insertion_sort_10.jpg" alt="Insertion Sort10"/><br><br>
        Algoritmayı uygulamaya devam ediyoruz ve 10 ile 14 değerlerinin de sıralı olmadığını tespit ediyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/InsertionSort/insertion_sort_11.jpg" alt="Insertion Sort11"/><br><br>
        Sıralı olmadıkları için bu değerlerin de yerlerini değiştiriyoruz ve 3 iterasyon sonucunda ilk 4 elemanın 3 elemanlı sıralanmış alt listesini elde etmiş bulunuyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/InsertionSort/insertion_sort_12.jpg" alt="Insertion Sort12"/><br><br>
        Aynı işlemlere sıralanmamış tüm değerler sıralanmış bir alt listeye yerleşene kadar devam ediyoruz ve nihai olarak listemizi sıralı bir şekilde elde ediyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/MergeSort/merge_sort.jpg" alt="Merge Sort6"/><br><br>
    </li>
    <li>
        <b id="selection-sort">Selection Sort</b> - Selection sort algoritması, sıralamak istediğimiz listeyi soldaki sıralanmış alt liste ve sağdaki sıralanmamış alt liste olacak şekilde ikiye ayıran karşılaştırma tabanlı bir algoritmadır. Başlangıçta, sıralanan taraf boştur ve sıralanmamış taraf ise listenin tamamıdır. Listenin en küçük elemanı sıralanmamış kısımdan seçilir, en soldaki eleman ile değiştirilir ve bu eleman artık sıralanan dizinin elemanı olur. Bu işleme sıralama işlemi bitene kadar, sıralanmamış dizinin alt sınırını birer birer arttırarak devam ederiz. Aşağıdaki sıralanmamış dizi üzerinde selection sort algoritmasını uygulayalım.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/SelectionSort/unsorted_array.jpg" alt="Selection Sort0"/><br><br>
        Sıralanmış listedeki ilk konum için listedeki tüm elemanları sırayla tarıyoruz ve 10 değerinin listedeki en küçük değer olduğunu tespit ediyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/SelectionSort/selection_sort_1.jpg" alt="Selection Sort1"/><br><br>
        Bu yüzden listenin ilk indisindeki 14 değeri ile 10 değerlerinin yerlerini değiştiriyoruz. Böylece sıralanmamış listenin en küçük elemanı olan 10 değeri sıralanmış listenin ilk konumuna yerleşmiş oldu.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/SelectionSort/selection_sort_2.jpg" alt="Selection Sort2"/><br><br>
        Sıralanmamış listenin alt sınırını 1 arttırarak algoritmayı uygulamaya devam ediyoruz ve 33 değerinin bulunduğu ikinci konum, yani artık sıralanmamış listenin ilk konumu için listenin geri kalanını doğrusal bir şekilde arıyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/SelectionSort/selection_sort_3.jpg" alt="Selection Sort3"/><br><br>
        14 değerinin listedeki en küçük ikinci değer olduğunu ve ikinci sırada, diğer bir deyişle de sıralanmamış listenin en küçük elemanı olduğunu ve sıralanmamış listenin ilk indisinde görünmesi gerektiğini tespit ediyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/SelectionSort/selection_sort_4.jpg" alt="Selection Sort4"/><br><br>
        İki iterasyondan sonra, en az iki değerin sıralı olarak konumlandırıldığını görüyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/SelectionSort/selection_sort_5.jpg" alt="Selection Sort5"/><br><br>
        Tüm dizi sıralanana kadar aynı işlemleri dizinin geri kalan elemanlarına uygulayarak selection sort algoritmasını tam olarak tamamlıyoruz.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/SelectionSort/selection_sort.jpg" alt="Selection Sort6"/><br><br>        
    </li>
    <li>
    <b id="quick-sort">Quick Sort</b> - Sıralanmak istenen veri dizisinin daha küçük dizilere parçalanmasına dayanan oldukça verimli bir sıralama algoritmasıdır. Büyük bir dizi, dizi içerisinde seçilen rastgele bir değerden(genelde dizinin sonuncu elemanı) daha küçük ve daha büyük değerleri tutacak olan iki diziye bölünür ve bu işlemi yaparken referans aldığımız değer işlem bittikten sonra pivot olarak adlandırılır. Daha sonra tekrar aynı algoritmayı bu pivot değerinin solunda kalan diziye ve sağında kalan diziye uygulayarak bu alt dizilerin pivot değerleri elde edilir. Böylece bu alt diziler de aynı işlemler sürecinde kendi alt dizilerine parçalanacaktır. Bu recursive(yinelemeli) işlemler parçalanmış dizilerin eleman sayısı 1 olduğunda son bulacaktır ve büyük dizimiz sıralanmış olacaktır.<br><br>
 &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<img src="https://github.com/zumrudu-anka/Algorithms/blob/master/Presentation/quick_sort_partition_animation.gif" alt="Quick Sort"/><br><br>
        Yukarıdaki animasyonu beraber inceleyelim. Öncelikle dizinin sonuncu elemanı referans değer olarak seçildi. Daha sonra dizinin en küçük indisi low index ve sondan ikinci indisi ise high index olarak seçildi. Low index değeri high index değerinden küçük olmak şartıyla<b>(1. kural)</b>; low index eleman değeri referans değerden küçük olduğu sürece<b>(2. kural)</b> low index değeri artırıldı ve high index eleman değeri referans değerden büyük olduğu sürece<b>(3. kural)</b> high index değeri azaltıldı. <b>1. kural</b> sağlandığı sürece <b>hem 2. hem de 3. kuralın</b> sağlanmadığı low index ve high index değerleri tespit edildiğinde bu indexlerin değerlerinin yerleri değiştirildi. <b>1. kural</b> bozulduğunda yani low index değerinin high index değerine eşit olma durumu söz konusu olduğunda, eşit oldukları index eleman değeri ile referans değerin yerleri değiştirildi ve referans değer pivot değer kabul edilerek liste bu pivot değerin sol tarafı ve sağ tarafı olmak üzere ikiye bölündü. Aynı işlemler bu bölünmüş diziler üzerinde de uygulanmaya devam edecek ve algoritma sonlandığında tüm dizi sıralanmış olacaktır.<br>
        &nbsp&nbsp&nbsp&nbsp&nbsp&nbspAynı algoritmaların çözümlerine farklı yaklaşımlar olabilir. Bu repository'den ulaşabileceğiniz Quick Sort algoritması çözümünde yine dizinin son elemanı referans değer olarak seçildi. Dizinin ilk index değeri low index olarak seçildi ve ilk eleman değerinden başlanarak dizinin sondan 2. elemanına kadar referans değerden küçük olan eleman ile dizinin low index değerindeki eleman değiştirildi ve low index değeri bu işlem her gerçekleştiğinde 1 arttırıldı. Bu iterasyon tamamlandığında referans değerden küçük olan değerlerin hepsi low index değerinin sol tarafında birikmiş oldu. Böylece bu low index değerinin ve sağ tarafındaki değerlerin referans değere eşit veya büyük olduğunu garantilemiş olduk. Low index değeri ile referans değerin yerini değiştirdiğimizde ise artık low index değeri referans aldığımız değeri göstermiş oldu ve böylece referans değerin sol tarafında bu değerden küçük elemanlar ve sağ tarafında ise kendisine eşit veya büyük elemanlar birikmiş oldu. Bu değeri pivot değer olarak seçtik ve büyük listeyi bu pivot değerin sol ve sağ tarafı olmak üzere ikiye böldük. Aynı işlemleri bu bölünmüş dizilere de uygulayarak algoritmamızı tamamladık.<br><br> 
    </li>
</ul>
